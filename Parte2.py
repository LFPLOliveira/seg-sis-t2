import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad, pad
from Crypto.Random import get_random_bytes

# Mensagens recebidas
c_hex = "595368231C1102FD98617004F4943A1D05252045DA0A194E8BF4C418D8E171E6D838822A76E88EB4E324E8A15D8C473076DC61E587B3DB849E31BC69BA72D969A1B0B50972CAB132DE701DE9D04E7E44"
sigc_hex = "0803AAAB1DEDC2E6BD6DFDD00E8D52280757407522990B2F77A7551013BBDFB16F5C2ECE0488A7CF3D7D6A5E85B640A72A0729554F1C77B91B0851620F4FCAED36B46A0AF7789E0BD91B14C945946FD4B8A0A717567C36CDD25771D1CA8F0EACC4FFBA145C2C6F310B1DB29A5653813D0B734A9158ED0322779D10CD4BEFDA7530A3C1853A8A79179823F7DF14431D142F70747766389CE8FE3CC15892B8FB3DAB97C45666F001CFD436BFBFB426F07E6324504D557DF25F8F9D4E9070E1E5AD19EDEED1BAF9EE5E7327755B4B327E84CBBA015B5A02022B8240C126D0670F1A4A7225BE012D9731180B71D7BF2A57FC839A1808277549A82A6E7B73BE4BC90D"
c = bytes.fromhex(c_hex)
sigc = int(sigc_hex, 16)

# Chave pública do professor
e_p_hex = "2E76A0094D4CEE0AC516CA162973C895"
N_p_hex = ("1985008F25A025097712D26B5A322982B6EBAFA5826B6EDA3B91F78B7BD63981382581218D33A9983E4E14D4B26113AA2A83BBCCFDE24310AEE3362B6100D06CC1EA429018A0FF3614C077F59DE55AADF449AF01E42ED6545127DC1A97954B89729249C6060BA4BD3A59490839072929C0304B2D7CBBA368AEBC4878A6F0DA3FE58CECDA638A506C723BDCBAB8C355F83C0839BF1457A3B6B89307D672BBF530C93F022E693116FE4A5703A665C6010B5192F6D1FAB64B5795876B2164C86ABD7650AEDAF5B6AFCAC0438437BB3BDF5399D80F8D9963B5414EAFBFA1AA2DD0D24988ACECA8D50047E5A78082295A987369A67D3E54FFB7996CBE2C5EAD794391")
N_p = int(N_p_hex, 16)
e_p = int(e_p_hex, 16)

mod_hex = "664f3063bb9c1bb0dddd50313f002fc4a870089f4cd928fca3a0d26152fd67cfa90387b6691908ea090b8890618c06af37022a9e27af8cb19d5a4a1d4d98a9664131b4bfc0232dfae8c22863bb0f73bc2e4fc4c1e86236d23929bd59ef35ac15a0f635bc9f34a1da6e65c6fd02417644660e4771b9baf8377c4b57f31c297512dd59144d3aa2d1e47d624e58c45192fa6550ff10aee95dfd5156dd27eeef9c7a9588ca21151b3b74a4eeec82d01d9d4fdbf719a8aa1c29d8e6994df9f9814859e08304516712a05d09f1291d0f2bfda767a07268159ce41b844c52acefbaeaa5ec3f6384af054f900521de853e401968bd37f24e1594080064bb7485c81e717a603e0fc7c8fbf991437efce9c9938d82b0278a0dff8cc0c1a01a85464af7cd54f06f909286d4eacfaa02fefd2d7aef4b9987da30c754096f435051820f5b72cd5653487847008e903013fab6e78e224796204d12674293a40129e63144fbb23eff5cf2ddca37f775b6872b1c49ec6b390c164591608976b7dc6681340032b488b3e57c227c558c721d21bf34ed5013371b0d7324f9600e85c21b6bc959ed7c309a5417b8203fa2e5110851d8f91431cb6fed6ef123c3106b859b141440883512702bfea35228ccb3e882bbf0a098ec379563d20e89a76c4374d631cc65e4c354e6c3b0caec580c80475c36940f3c494fea35d885a4b1519614bb54946f191963"
mod = int(mod_hex, 16)

# Chave do aluno (parte 1)
e = 4294967297
d_student = 117013022267796203920180510181885199795477712377175153288853613236230203340821483796391780232508019587325392083966134251393677347938489978306854100818188938299802241561357678926369590937655965853931562292533326390965156192829317122685168043830414272100218961141800542329258629450652867779687297231278658672155531438330602999516173062308262245185401436443414934634701026427985124899317707959795868161437751092873439610828457548889962438171059758735413425422215870969245912422965428514285372308293351357983414428215557602646912979482568762000630999153441801304003372195382572547795574881565568771871038549708635401699352725295990035571096345847411892736013486505874898443233947229134324064125167835825574899438242450327289422079058705003175572551020585839624127650669566459520154717604130083089115897852135326375780685895176907553855306747467260312043446217133502761498928840508589670417202516355680992920836247890563746418824313297932218727927053333145999339261005789158495958322224658878411995512773016025956012573828778745083933110927673484082996045197951113810635894782601144546668935665265341841371159374201653706262262137208732836547819829233030046026073754112512325892224459081759434453665089527355194395107569349988345520802993
d_hex = hex(d_student)
d = int(d_hex, 16)

# S guardado (parte 1)
s = 306734350739791326922686581663606986605
s_hex = hex(s)
s_bytes = s.to_bytes(16, byteorder='big')

# Nova variável s_bytes modificada
s_modified = (0x00 << (s.bit_length() + 8) | (s >> 8)
              ).to_bytes(16, byteorder='big')

# Verificar assinatura
h_c = hashlib.sha256(c).hexdigest()
print(f"SHA-256 of c: {h_c}")

h_c_calculated = pow(sigc, e_p, N_p)
h_c_calculated_hex = hex(h_c_calculated)[2:]
print(f"Hash calculated from signature: {h_c_calculated_hex}")

# confirmação da validade da assinatura
if h_c_calculated_hex != h_c:
    raise ValueError("Invalid signature.")

# Extrair IV e texto cifrado
iv = c[:16]
ciphertext = c[16:]

# Verifique se a chave de criptografia e o IV são do comprimento correto
assert len(
    s_modified) == 16, f"Chave de criptografia incorreta: {len(s_modified)} bytes"
assert len(iv) == 16, f"IV incorreto: {len(iv)} bytes"

# Decriptar
cipher = AES.new(s_modified, AES.MODE_CBC, iv)
try:
    decrypted_data = cipher.decrypt(ciphertext)
    print(
        f"Decrypted data (before unpadding): {decrypted_data.hex()} (Length: {len(decrypted_data)})")

    m = unpad(decrypted_data, AES.block_size)
    print(f"Decrypted message: {m.decode()}")
except (ValueError, KeyError) as e:
    print(f"Decryption failed: {e}")
    raise

# Mensagem inversa
m_inv = m[::-1]

# Gerar IV aleatório
iv_inv = get_random_bytes(16)

# Encriptar mensagem reversa
cipher_inv = AES.new(s_modified, AES.MODE_CBC, iv_inv)
c_inv = iv_inv + cipher_inv.encrypt(pad(m_inv, AES.block_size))

# Calcular hash e assinar
h_inv = hashlib.sha256(c_inv).hexdigest()
print(f"SHA-256 of encrypted reversed message: {h_inv}")

# Assinar a mensagem
h_inv_int = int(h_inv, 16)
sig_inv = pow(h_inv_int, d, mod)

c_inv_hex = c_inv.hex()
sig_inv_hex = hex(sig_inv)[2:]

print(f"c_inv: {c_inv_hex}\nsig_inv: {sig_inv_hex}")
